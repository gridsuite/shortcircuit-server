/**
 * Copyright (c) 2023, RTE (http://www.rte-france.com)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package org.gridsuite.shortcircuit.server.reports;

import com.powsybl.commons.report.*;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.gridsuite.shortcircuit.server.service.ShortCircuitRunContext;
import org.springframework.stereotype.Component;

/**
 * This class manages how to postprocess reports of the short-circuit server to reduce the number of reports
 * by aggregating them.
 * <br/>
 * The tree structure returned by short-circuit is:
 * <pre>
 * 00000000-0000-0000-0000-000000000000@ShortCircuitAnalysis  or  ShortCircuitAnalysis
 * \-- ShortCircuitAnalysis -> "ShortCircuitAnalysis (${providerToUse})"
 *     +-- generatorConversion -> "Conversion of generators"
 *     +-- batteryConversion -> "Conversion of the batteries"
 *     +-- branchConversion -> "Conversion of branches"
 *     |   +-- lineConversion -> "Conversion of lines"
 *     |   +-- tieLineConversion -> "Conversion of tie lines"
 *     |   +-- twoWindingsTransformerConversion -> "Conversion of two windings transformers"
 *     |   \-- threeWindingsTransformerConversion -> "Conversion of three windings transformers"
 *     +-- danglinglinesConversion -> "Conversion of the dangling lines"
 *     \-- extkey -> "Logs generated by an extension (provider)"
 * </pre>
 *
 * @implNote as the tree to aggregate seems relatively simple, a simple utility class will suffice
 *
 * @see ReportNode
 */
@Slf4j
@Component
public class ReportMapperShortCircuit extends AbstractReportMapper {
    @AllArgsConstructor
    private enum ConversionEquipmentType {
        GENERATOR("generators", "generatorConversion", "disconnectedTerminalGenerator", "disconnectedTerminalGeneratorSummary"),
        BATTERY("batteries", "batteryConversion", "disconnectedTerminalGenerator", "disconnectedTerminalBatterySummary");

        public final String equipmentsLabel;
        public final String conversionMessageKey;
        public final String disconnectedTerminalMessageKey;
        public final String summaryMessageKey;
    }

    /**
     * Modify node with key {@code ShortCircuitAnalysis}
     *
     * @implNote we assume there will always be at least one modification
     */
    @Override
    protected ReportNode forShortCircuitAnalysis(@NonNull final ReportNode reportNode, ShortCircuitRunContext runContext) {
        ReportNodeBuilder builder = ReportNode.newRootReportNode()
                .withMessageTemplate(reportNode.getMessageKey(), reportNode.getMessageTemplate());
        reportNode.getValues().entrySet().forEach(entry -> builder.withTypedValue(entry.getKey(), entry.getValue().getValue().toString(), entry.getValue().getType()));
        final ReportNode newReporter = builder.build();
        if (!runContext.getVoltageLevelsWithWrongIsc().isEmpty()) {
            logVoltageLevelsWithWrongIpValues(reportNode, runContext);
        }
        reportNode.getChildren().forEach(child -> {
            if (ConversionEquipmentType.GENERATOR.conversionMessageKey.equals(child.getMessageKey())) {
                insertReportNode(newReporter, forEquipmentConversion(child, ConversionEquipmentType.GENERATOR));
            } else if (ConversionEquipmentType.BATTERY.conversionMessageKey.equals(child.getMessageKey())) {
                insertReportNode(newReporter, forEquipmentConversion(child, ConversionEquipmentType.BATTERY));
            } else {
                insertReportNode(newReporter, child);
            }
        });
        return newReporter;
    }

    protected void logVoltageLevelsWithWrongIpValues(ReportNode reportNode, ShortCircuitRunContext runContext) {
        ReportNode newReportNode = reportNode.newReportNode()
            .withMessageTemplate("VoltageLevelsWithWrongIpValuesRoot", "Voltage levels having wrong isc values")
            .add();
        newReportNode.newReportNode().withMessageTemplate("VoltageLevelsWithWrongIpValues",
            "Some voltage levels have wrong isc values, isc min must be <= isc max : "
                + StringUtils.join(runContext.getVoltageLevelsWithWrongIsc(), ", "))
            .withTypedValue(ReportConstants.SEVERITY_KEY, TypedValue.ERROR_SEVERITY.toString(), TypedValue.SEVERITY)
            .add();
    }

    /**
     * Modify node with key equals to {@link ConversionEquipmentType#disconnectedTerminalMessageKey}
     * @implNote we use {@link ReportNode} to insert a {@link ReportNode} without knowing the exact content at that time, and
     *           filling it later
     */
    protected ReportNode forEquipmentConversion(@NonNull final ReportNode reportNode, ConversionEquipmentType conversionEquipmentType) {
        log.trace("short-circuit logs detected, will analyse them...");
        ReportNodeBuilder builder = ReportNode.newRootReportNode()
                .withMessageTemplate(reportNode.getMessageKey(), reportNode.getMessageTemplate());
        reportNode.getValues().entrySet().forEach(entry -> builder.withTypedValue(entry.getKey(), entry.getValue().getValue().toString(), entry.getValue().getType()));
        final ReportNode newReporter = builder.build();

        /* preparing */
        long logsRegulatingTerminalCount = 0L;
        ReportNodeAdder logsRegulatingTerminalSummaryAdder = null;
        TypedValue logsRegulatingTerminalSeverity = null;
        for (final ReportNode child : reportNode.getChildren()) {
            if (conversionEquipmentType.disconnectedTerminalMessageKey.equals(child.getMessageKey())) {
                //we match line "Regulating terminal of connected ... MY-NODE is disconnected. Regulation is disabled."
                if (logsRegulatingTerminalSummaryAdder == null) {
                    logsRegulatingTerminalSummaryAdder = newReporter.newReportNode();
                    logsRegulatingTerminalSeverity = child.getValue(ReportConstants.SEVERITY_KEY).get();
                }
                copyReportAsTrace(newReporter, child);
                logsRegulatingTerminalCount++;
            } else {
                insertReportNode(newReporter, child);
            }
        }

        /* finalize computation of summaries */
        log.debug("Found {} lines in shortcircuit logs matching \"Regulating terminal of connected {} MYNODE is disconnected. Regulation is disabled.\"", logsRegulatingTerminalCount, conversionEquipmentType.equipmentsLabel);
        if (logsRegulatingTerminalSummaryAdder != null) {
            logsRegulatingTerminalSummaryAdder
                .withMessageTemplate(conversionEquipmentType.summaryMessageKey, "Regulating terminal of ${nb} connected ${equipmentsLabel} is disconnected. Regulation is disabled.")
                .withTypedValue(ReportConstants.SEVERITY_KEY, ObjectUtils.defaultIfNull(logsRegulatingTerminalSeverity, TypedValue.WARN_SEVERITY).toString(), TypedValue.SEVERITY)
                .withTypedValue("nb", logsRegulatingTerminalCount, TypedValue.UNTYPED)
                .withTypedValue("equipmentsLabel", conversionEquipmentType.equipmentsLabel, TypedValue.UNTYPED)
                .add();
        }

        return newReporter;
    }
}
