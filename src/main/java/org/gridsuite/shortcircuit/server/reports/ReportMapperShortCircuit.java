/**
 * Copyright (c) 2023, RTE (http://www.rte-france.com)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package org.gridsuite.shortcircuit.server.reports;

import com.powsybl.commons.reporter.Report;
import com.powsybl.commons.reporter.Reporter;
import com.powsybl.commons.reporter.ReporterModel;
import com.powsybl.commons.reporter.TypedValue;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * This class manages how to postprocess reports of the short-circuit server to reduce the number of reports
 * by aggregating them.
 * <br/>
 * The tree structure returned by short-circuit is:
 * <pre>
 * 00000000-0000-0000-0000-000000000000@ShortCircuitAnalysis  or  ShortCircuitAnalysis
 * \-- ShortCircuitAnalysis -> "ShortCircuitAnalysis (${providerToUse})"
 *     +-- generatorConversion -> "Conversion of generators"
 *     +-- batteryConversion -> "Conversion of the batteries"
 *     +-- branchConversion -> "Conversion of branches"
 *     |   +-- lineConversion -> "Conversion of lines"
 *     |   +-- tieLineConversion -> "Conversion of tie lines"
 *     |   +-- twoWindingsTransformerConversion -> "Conversion of two windings transformers"
 *     |   \-- threeWindingsTransformerConversion -> "Conversion of three windings transformers"
 *     +-- danglinglinesConversion -> "Conversion of the dangling lines"
 *     \-- extkey -> "Logs generated by an extension (provider)"
 * </pre>
 *
 * @implNote as the tree to aggregate seems relatively simple, a simple utility class will suffice
 *
 * @see Reporter
 * @see ReporterModel
 * @see Report
 */
@Slf4j
@Component
public class ReportMapperShortCircuit extends AbstractReportMapper {
    /**
     * Modify node with key {@code ShortCircuitAnalysis}
     *
     * @implNote we assume there will always be at least one modification
     */
    @Override
    protected ReporterModel forShortCircuitAnalysis(@NonNull final ReporterModel reporterModel) {
        final ReporterModel newReporter = new ReporterModel(reporterModel.getTaskKey(), reporterModel.getDefaultName(), reporterModel.getTaskValues());
        reporterModel.getReports().forEach(newReporter::report);
        reporterModel.getSubReporters().forEach(reporter -> newReporter.addSubReporter(
            switch (reporter.getTaskKey()) {
                case "generatorConversion" -> forGeneratorConversion(reporter);
                default -> reporter;
            }));
        return newReporter;
    }

    /**
     * Modify node with key {@code generatorConversion}
     */
    protected ReporterModel forGeneratorConversion(@NonNull final ReporterModel reporterModel) {
        log.trace("short-circuit logs detected, will analyse them...");
        final ReporterModel newReporter = new ReporterModel(reporterModel.getTaskKey(), reporterModel.getDefaultName(), reporterModel.getTaskValues());
        reporterModel.getSubReporters().forEach(newReporter::addSubReporter);

        /* preparing */
        final List<String> logsRegulatingTerminalList = new ArrayList<>(newReporter.getReports().size());
        ReportWrapper logsRegulatingTerminalSummary = null;
        TypedValue logsRegulatingTerminalSeverity = null;

        /* analyze and compute logs in one pass */
        for (final Report report : reporterModel.getReports()) { //we modify logs conditionally here
            if ("disconnectedTerminalGenerator".equals(report.getReportKey())) {
                //we match line "Regulating terminal of connected generator MY-NODE is disconnected. Regulation is disabled."
                if (logsRegulatingTerminalSummary == null) {
                    logsRegulatingTerminalSummary = new ReportWrapper();
                    newReporter.report(logsRegulatingTerminalSummary);
                    logsRegulatingTerminalSeverity = report.getValue(Report.REPORT_SEVERITY_KEY);
                }
                ReportsUtils.copyReportAsTrace(newReporter, report);
                final TypedValue generator = report.getValue("generator");
                if (generator != null && generator.getValue() != null) {
                    logsRegulatingTerminalList.add(Objects.toString(generator.getValue()));
                }
            } else { //we keep this log as is
                newReporter.report(report);
            }
        }

        /* finalize computation of summaries */
        log.debug("Found {} lines in shortcircuit logs matching \"Regulating terminal of connected generator MYNODE is disconnected. Regulation is disabled.\"", logsRegulatingTerminalList.size());
        if (logsRegulatingTerminalSummary != null) {
            logsRegulatingTerminalSummary.setReport(new Report("disconnectedTerminalGeneratorSummary",
                    "Regulating terminal of ${nb} connected generators is disconnected. Regulation is disabled.\n${nodes}",
                    Map.of(Report.REPORT_SEVERITY_KEY, ObjectUtils.defaultIfNull(logsRegulatingTerminalSeverity, TypedValue.WARN_SEVERITY),
                            "nb", new TypedValue(logsRegulatingTerminalList.size(), TypedValue.UNTYPED),
                            "nodes", new TypedValue(String.join(", ", logsRegulatingTerminalList), TypedValue.UNTYPED))));
        }

        return newReporter;
    }
}
