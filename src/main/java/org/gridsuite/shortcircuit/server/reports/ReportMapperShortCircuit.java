/**
 * Copyright (c) 2023, RTE (http://www.rte-france.com)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package org.gridsuite.shortcircuit.server.reports;

import com.powsybl.commons.report.*;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.gridsuite.shortcircuit.server.service.ShortCircuitRunContext;
import org.springframework.stereotype.Component;

import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

/**
 * This class manages how to postprocess reports of the short-circuit server to reduce the number of reports
 * by aggregating them.
 * <br/>
 * The tree structure returned by short-circuit is:
 * <pre>
 * 00000000-0000-0000-0000-000000000000@ShortCircuitAnalysis  or  ShortCircuitAnalysis
 * \-- ShortCircuitAnalysis -> "ShortCircuitAnalysis (${providerToUse})"
 *     +-- generatorConversion -> "Conversion of generators"
 *     +-- batteryConversion -> "Conversion of the batteries"
 *     +-- branchConversion -> "Conversion of branches"
 *     |   +-- lineConversion -> "Conversion of lines"
 *     |   +-- tieLineConversion -> "Conversion of tie lines"
 *     |   +-- twoWindingsTransformerConversion -> "Conversion of two windings transformers"
 *     |   \-- threeWindingsTransformerConversion -> "Conversion of three windings transformers"
 *     +-- danglinglinesConversion -> "Conversion of the dangling lines"
 *     \-- extkey -> "Logs generated by an extension (provider)"
 * </pre>
 *
 * @implNote as the tree to aggregate seems relatively simple, a simple utility class will suffice
 *
 * @see ReportNode
 */
@Slf4j
@Component
public class ReportMapperShortCircuit extends AbstractReportMapper {
    private enum ConversionEquipmentType {
        GENERATOR("generators",
            "generatorConversion",
            "generatorConversion",
            "disconnectedTerminalGenerator",
            "disconnectedTerminalGeneratorSummary",
            "Regulating terminal of ${nb} connected ${equipmentsLabel} is disconnected. Regulation is disabled."),
        BATTERY("batteries",
            "batteryConversion",
            "batteryConversion",
            "disconnectedTerminalGenerator",
            "disconnectedTerminalBatterySummary",
            "Regulating terminal of ${nb} connected ${equipmentsLabel} is disconnected. Regulation is disabled."),
        TWO_WINDINGS_TRANSFORMER("two windings transformers",
            "branchConversion",
            "twoWindingsTransformerConversion",
            "addConstantRatio",
            "addConstantRatioSummary",
            "Adding constant ratio voltage transformation on ${nb} ${equipmentsLabel} because both voltage levels have different nominal voltage"
            ),
        LINE("lines",
            "branchConversion",
            "lineConversion",
            null,
            null,
            null
            ),
        THREE_WINDINGS_TRANSFORMER("three windings transformers",
            "branchConversion",
            "threeWindingsTransformerConversion",
            null,
            null,
            null
            ),
        TIE_LINE("tie lines",
            "branchConversion",
            "tieLineConversion",
            null,
            null,
            null
            );

        public final String equipmentsLabel;
        public final String parentConversionMessageKey;
        public final String conversionMessageKey;
        public final String toSummarizeMessageKey;
        public final String summaryMessageKey;
        public final String summaryMessageTemplate;

        ConversionEquipmentType(String equipmentsLabel,
                                String parentConversionMessageKey,
                                String conversionMessageKey,
                                String toSummarizeMessageKey,
                                String summaryMessageKey,
                                String summaryMessageTemplate) {
            this.equipmentsLabel = equipmentsLabel;
            this.parentConversionMessageKey = parentConversionMessageKey;
            this.conversionMessageKey = conversionMessageKey;
            this.toSummarizeMessageKey = toSummarizeMessageKey;
            this.summaryMessageKey = summaryMessageKey;
            this.summaryMessageTemplate = summaryMessageTemplate;
        }
    }

    /**
     * Modify node with key {@code ShortCircuitAnalysis}
     *
     * @implNote we assume there will always be at least one modification
     */
    @Override
    protected ReportNode forShortCircuitAnalysis(@NonNull final ReportNode reportNode, ShortCircuitRunContext runContext) {
        ReportNodeBuilder builder = ReportNode.newRootReportNode()
                .withMessageTemplate(reportNode.getMessageKey(), reportNode.getMessageTemplate());
        reportNode.getValues().forEach((key, value) -> builder.withTypedValue(key, value.getValue().toString(), value.getType()));
        final ReportNode newReporter = builder.build();
        if (!runContext.getVoltageLevelsWithWrongIsc().isEmpty()) {
            logVoltageLevelsWithWrongIpValues(reportNode, runContext);
        }
        reportNode.getChildren().forEach(child -> {
            if (child.getMessageKey().equals(ConversionEquipmentType.GENERATOR.parentConversionMessageKey)) {
                insertReportNode(newReporter, forEquipmentConversion(child, ConversionEquipmentType.GENERATOR));
            } else if (child.getMessageKey().equals(ConversionEquipmentType.BATTERY.parentConversionMessageKey)) {
                insertReportNode(newReporter, forEquipmentConversion(child, ConversionEquipmentType.BATTERY));
            } else if (child.getMessageKey().equals(ConversionEquipmentType.TWO_WINDINGS_TRANSFORMER.parentConversionMessageKey)) {
                insertReportNode(newReporter, forEquipmentConversion(child, ConversionEquipmentType.TWO_WINDINGS_TRANSFORMER));
            } else {
                insertReportNode(newReporter, child);
            }
        });
        return newReporter;
    }

    protected void logVoltageLevelsWithWrongIpValues(ReportNode reportNode, ShortCircuitRunContext runContext) {
        ReportNode newReportNode = reportNode.newReportNode()
            .withMessageTemplate("VoltageLevelsWithWrongIpValuesRoot", "Voltage levels having wrong isc values")
            .add();
        newReportNode.newReportNode().withMessageTemplate("VoltageLevelsWithWrongIpValues",
            "Some voltage levels have wrong isc values, isc min must be <= isc max : "
                + StringUtils.join(runContext.getVoltageLevelsWithWrongIsc(), ", "))
            .withTypedValue(ReportConstants.SEVERITY_KEY, TypedValue.ERROR_SEVERITY.toString(), TypedValue.SEVERITY)
            .add();
    }

    private void insertAndCount(ReportNode child, ReportNode parent, AtomicReference<ReportNodeAdder> logsToSummarizeAdder,
                                AtomicLong logsToSummarizeCount, AtomicReference<TypedValue> logsToSummarizeSeverity, ConversionEquipmentType conversionEquipmentType) {
        if (child.getMessageKey().equals(conversionEquipmentType.toSummarizeMessageKey)) {
            if (logsToSummarizeAdder.get() == null) {
                logsToSummarizeAdder.set(parent.newReportNode());
                logsToSummarizeSeverity.set(child.getValue(ReportConstants.SEVERITY_KEY).orElse(TypedValue.WARN_SEVERITY));
            }
            copyReportAsTrace(parent, child);
            logsToSummarizeCount.incrementAndGet();
        } else {
            insertReportNode(parent, child);
        }
    }

    /**
     * Modify node with key equals to {@code ConversionEquipmentType.toSummarizeMessageKey}
     * @implNote we use {@link ReportNode} to insert a {@link ReportNode} without knowing the exact content at that time, and
     *           filling it later
     */
    @SuppressWarnings("checkstyle:UnnecessaryParentheses")
    protected ReportNode forEquipmentConversion(@NonNull final ReportNode reportNode, ConversionEquipmentType conversionEquipmentType) {
        log.trace("short-circuit logs detected, will analyse them...");

        ReportNodeBuilder builder = ReportNode.newRootReportNode()
                .withMessageTemplate(reportNode.getMessageKey(), reportNode.getMessageTemplate());
        reportNode.getValues().forEach((key, value) -> builder.withTypedValue(key, value.getValue().toString(), value.getType()));
        final ReportNode newReporter = builder.build();

        /* preparing */
        AtomicLong logsToSummarizeCount = new AtomicLong(0L);
        AtomicReference<ReportNodeAdder> logsToSummarizeAdder = new AtomicReference<>();
        AtomicReference<TypedValue> logsToSummarizeSeverity = new AtomicReference<>();
        for (final ReportNode child : reportNode.getChildren()) {
            if (conversionEquipmentType == ConversionEquipmentType.GENERATOR ||
                conversionEquipmentType == ConversionEquipmentType.BATTERY) {
                insertAndCount(child, newReporter, logsToSummarizeAdder, logsToSummarizeCount, logsToSummarizeSeverity, conversionEquipmentType);
            } else if (conversionEquipmentType == ConversionEquipmentType.TWO_WINDINGS_TRANSFORMER) {
                // to keep the reports hierarchy : reports for two windings transformers are inside the branches report hierarchy
                ReportNodeBuilder builder2 = ReportNode.newRootReportNode().withMessageTemplate(child.getMessageKey(), child.getMessageTemplate());
                child.getValues().forEach((key, value) -> builder2.withTypedValue(key, value.getValue().toString(), value.getType()));
                final ReportNode insertedReport = builder2.build();
                ReportNode newReporter2 = insertReportNode(newReporter, insertedReport);

                for (final ReportNode child2 : child.getChildren()) {
                    insertAndCount(child2, newReporter2, logsToSummarizeAdder, logsToSummarizeCount, logsToSummarizeSeverity, conversionEquipmentType);
                }
            }
        }

        /* finalize computation of summaries */
        log.debug("Found {} lines in shortcircuit logs matching {}", logsToSummarizeCount.get(), conversionEquipmentType.toSummarizeMessageKey);
        if (logsToSummarizeAdder.get() != null) {
            logsToSummarizeAdder.get()
                .withMessageTemplate(conversionEquipmentType.summaryMessageKey, conversionEquipmentType.summaryMessageTemplate)
                .withTypedValue(ReportConstants.SEVERITY_KEY, ObjectUtils.defaultIfNull(logsToSummarizeSeverity.get(), TypedValue.WARN_SEVERITY).toString(), TypedValue.SEVERITY)
                .withTypedValue("nb", logsToSummarizeCount.get(), TypedValue.UNTYPED)
                .withTypedValue("equipmentsLabel", conversionEquipmentType.equipmentsLabel, TypedValue.UNTYPED)
                .add();
        }

        return newReporter;
    }
}
