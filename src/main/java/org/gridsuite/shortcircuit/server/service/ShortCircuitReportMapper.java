/**
 * Copyright (c) 2023, RTE (http://www.rte-france.com)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package org.gridsuite.shortcircuit.server.service;

import com.google.common.annotations.VisibleForTesting;
import com.powsybl.commons.reporter.Report;
import com.powsybl.commons.reporter.Reporter;
import com.powsybl.commons.reporter.ReporterModel;
import com.powsybl.commons.reporter.TypedValue;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * This class manages how to postprocess reports of the proprietary courcir simulator to reduce the number of reports
 * by aggregating them.
 * <br/>
 * The tree structure returned by the courcirc proprietary simulator is:
 * <pre>
 * 00000000-0000-0000-0000-000000000000@ShortCircuitAnalysis  or  ShortCircuitAnalysis
 * \-- ShortCircuitAnalysis -> "ShortCircuitAnalysis (${providerToUse})"
 *     +-- generatorConversion -> "Conversion of generators"
 *     +-- batteryConversion -> "Conversion of the batteries"
 *     +-- branchConversion -> "Conversion of branches"
 *     |   +-- lineConversion -> "Conversion of lines"
 *     |   +-- tieLineConversion -> "Conversion of tie lines"
 *     |   +-- twoWindingsTransformerConversion -> "Conversion of two windings transformers"
 *     |   \-- threeWindingsTransformerConversion -> "Conversion of three windings transformers"
 *     +-- danglinglinesConversion -> "Conversion of the dangling lines"
 *     \--courcirc -> "Logs generated by Courcirc simulator"
 * </pre>
 *
 * @implNote as the tree to aggregate seems relatively simple, a simple utility class will suffice
 *
 * @see com.powsybl.commons.reporter.Reporter
 * @see com.powsybl.commons.reporter.ReporterModel
 * @see com.powsybl.commons.reporter.Report
 */
@Slf4j
@Component
public class ShortCircuitReportMapper {
    private static final String PATTERN_TRANSIENT_REACTANCE_TOO_LOW = " : transient reactance too low ==> generator ignored";

    /**
     * Will try to modify the reporter
     * @param reporter the reporter to modify
     * @return the result
     *
     * @implNote currently support only some implementations of {@link Reporter}
     */
    public Reporter modifyReporter(@NonNull final Reporter reporter) {
        if (reporter instanceof ReporterModel reporterModel && reporterModel.getTaskKey().matches("^([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}@)?ShortCircuitAnalysis$")) {
            log.debug("ShortCircuitAnalysis root node found, will modify it!");
            return forUuidAtShortCircuitAnalysis(reporterModel);
        } else {
            log.trace("Unrecognized Reporter: {}", reporter);
            return reporter;
        }
    }

    /**
     * Modify node with key {@code ********-****-****-****-************@ShortCircuitAnalysis} or {@code ShortCircuitAnalysis}
     *
     * @implNote we assume there will always be at least one modification
     */
    private Reporter forUuidAtShortCircuitAnalysis(@NonNull final ReporterModel reporterModel) {
        final ReporterModel newReporter = new ReporterModel(reporterModel.getTaskKey(), reporterModel.getDefaultName(), reporterModel.getTaskValues());
        reporterModel.getReports().forEach(newReporter::report);
        reporterModel.getSubReporters().forEach(reporter -> {
            if ("ShortCircuitAnalysis".equals(reporter.getTaskKey())
                && "Courcirc".equals(reporter.getTaskValues().getOrDefault("providerToUse", new TypedValue("", "")).getValue())) {
                newReporter.addSubReporter(forShortCircuitAnalysis(reporter));
            } else {
                newReporter.addSubReporter(reporter);
            }
        });
        return newReporter;
    }

    /**
     * Modify node with key {@code ShortCircuitAnalysis}
     *
     * @implNote we assume there will always be at least one modification
     */
    private ReporterModel forShortCircuitAnalysis(@NonNull final ReporterModel reporterModel) {
        final ReporterModel newReporter = new ReporterModel(reporterModel.getTaskKey(), reporterModel.getDefaultName(), reporterModel.getTaskValues());
        reporterModel.getReports().forEach(newReporter::report);
        reporterModel.getSubReporters().forEach(reporter -> newReporter.addSubReporter(
            switch (reporter.getTaskKey()) {
                case "courcirc" -> forCourcirc(reporter);
                default -> reporter;
            }));
        return newReporter;
    }

    /**
     * Modify node with key {@code courcirc}
     * <br/>
     * The relevant part of the tree structure created by the courcirc proprietary simulator output is:
     * <pre>
     * 00000000-0000-0000-0000-000000000000@ShortCircuitAnalysis
     * \-- ShortCircuitAnalysis -> "ShortCircuitAnalysis (${providerToUse})"
     *     \-- courcirc -> "Logs generated by Courcirc simulator"
     * </pre>
     * this courcirc reporter, among other useful reports, contains hundreds of reports that are counted and replaced
     * by a single aggregate report.<br/>
     *
     * @apiNote the main goal here is to concat specific log lines with a huge number of repetitions into one summary line
     *          and change existing lines found to {@code TRACE} severity
     * @implNote courcirc logs don't seem to use enumerate keys neither template value, only incremental keys (REC_0,REC_1,...),
     *           so we need to test the message
     */
    private ReporterModel forCourcirc(@NonNull final ReporterModel reporterModel) {
        log.trace("courcirc logs detected, will analyse them...");
        final ReporterModel newReporter = new ReporterModel(reporterModel.getTaskKey(), reporterModel.getDefaultName(), reporterModel.getTaskValues());
        reporterModel.getSubReporters().forEach(newReporter::addSubReporter);
        /* preparing */
        final List<String> logsTransientReactanceTooLow = new ArrayList<>(newReporter.getReports().size());
        /* analyze and compute logs in one pass */
        for (final Report report : reporterModel.getReports()) { //we modify logs conditionally here
            if (StringUtils.endsWith(report.getDefaultMessage(), PATTERN_TRANSIENT_REACTANCE_TOO_LOW)) { //we match line "X.ABCDEF1 : transient reactance too low ==> generator ignored"
                logsTransientReactanceTooLow.add(StringUtils.removeEnd(report.getDefaultMessage(), PATTERN_TRANSIENT_REACTANCE_TOO_LOW).trim()); //... to get the node name
                copyReportAsTrace(newReporter, report);
            } else { //we keep this log as is
                newReporter.report(report);
            }
        }
        /* finalize computation */
        log.debug("Found {} lines in courcirc logs matching \"MYNODE : transient reactance too low ==> generator ignored\"", logsTransientReactanceTooLow.size());
        if (!logsTransientReactanceTooLow.isEmpty()) {
            newReporter.report("TransientReactanceTooLow", "${nb} node(s) with transient reactance too low ==> generator ignored\n${nodes}",
                                Map.of(Report.REPORT_SEVERITY_KEY, TypedValue.WARN_SEVERITY,
                                       "nb", new TypedValue(logsTransientReactanceTooLow.size(), TypedValue.UNTYPED),
                                       "nodes", new TypedValue(String.join(", ", logsTransientReactanceTooLow), TypedValue.UNTYPED)));
        }
        return newReporter;
    }

    /**
     * Because {@link TypedValue#equals(Object)} isn't override, we must test it ourselves.
     * @param obj1 first object to test
     * @param obj2 second object to test
     * @return {@code true} if equals, else {@code false}
     */
    private static boolean equalsTypedValue(final TypedValue obj1, final TypedValue obj2) {
        if (obj1 == obj2) {
            return true;
        } else if (obj1 != null && obj2 != null) {
            return Objects.equals(obj1.getType(), obj2.getType()) && Objects.equals(obj1.getValue(), obj2.getValue());
        } else {
            return false;
        }
    }

    /**
     * Copy the report, but with {@link TypedValue#TRACE_SEVERITY} severity
     * @param reporterModel the {@link ReporterModel reporter} to wich add the modified {@link Report}
     * @param report the report to copy with {@code TRACE} severity
     */
    @VisibleForTesting
    protected static void copyReportAsTrace(@NonNull final ReporterModel reporterModel, @NonNull final Report report) {
        //TODO use .equals() when implemented in TypedValue
        if (equalsTypedValue(TypedValue.TRACE_SEVERITY, report.getValue(Report.REPORT_SEVERITY_KEY))) {
            reporterModel.report(report); //no change needed
        } else {
            final Map<String, TypedValue> values = new HashMap<>(report.getValues());
            values.put(Report.REPORT_SEVERITY_KEY, TypedValue.TRACE_SEVERITY);
            reporterModel.report(new Report(report.getReportKey(), report.getDefaultMessage(), values));
        }
    }
}
