package org.gridsuite.shortcircuit.server;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.powsybl.commons.reporter.Reporter;
import com.powsybl.commons.reporter.ReporterModel;
import com.powsybl.commons.reporter.TypedValue;
import com.powsybl.shortcircuit.ShortCircuitAnalysis;
import lombok.extern.slf4j.Slf4j;
import org.assertj.core.api.WithAssertions;
import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
import org.gridsuite.shortcircuit.server.assertj.WithCustomAssertions;
import org.gridsuite.shortcircuit.server.service.ReportMapper;
import org.gridsuite.shortcircuit.server.service.ShortCircuitRunContext;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;

import java.util.Map;
import java.util.UUID;

/**
 * @see org.gridsuite.shortcircuit.server.service.ShortCircuitWorkerService#run(ShortCircuitRunContext, UUID)
 */
@Slf4j
@Tag("UnitTest")
class ReporterLogsTest implements WithAssertions, WithCustomAssertions {
    private final ReportMapper reportMapper = new ReportMapper();

    static final String ROOT_REPORTER_ID = "00000000-0000-0000-0000-000000000000@ShortCircuitAnalysis";
    static final String SHORTCIRCUIT_TYPE_REPORT = "ShortCircuitAnalysis";

    private static ReporterModel rootReporter;

    @BeforeAll
    static void prepare() {
        rootReporter = new ReporterModel(ROOT_REPORTER_ID, ROOT_REPORTER_ID);
        final Reporter reporter = rootReporter.createSubReporter(SHORTCIRCUIT_TYPE_REPORT, SHORTCIRCUIT_TYPE_REPORT + " (${providerToUse})", "providerToUse", ShortCircuitAnalysis.find().getName());
        //assertThat(reporter).isInstanceOf(ReporterModel.class);
        reporter.createSubReporter("generatorConversion", "Conversion of generators")
                .report("disconnectedTerminalGenerator", "Regulating terminal of connected generator ${generator} is disconnected. Regulation is disabled.", "generator", "TestGenerator");
        {
            final Reporter reporter1 = reporter.createSubReporter("batteryConversion", "Conversion of the batteries");
            reporter1.createSubReporter("lineConversion", "Conversion of lines");
            reporter1.createSubReporter("tieLineConversion", "Conversion of tie lines");
            reporter1.createSubReporter("twoWindingsTransformerConversion", "Conversion of two windings transformers");
            reporter1.createSubReporter("threeWindingsTransformerConversion", "Conversion of three windings transformers");
        }
        reporter.createSubReporter("danglinglinesConversion", "Conversion of the dangling lines");
        final Reporter reporterCourcirc = reporter.createSubReporter("courcirc", "Logs generated by Courcirc simulator");
        {
            int recNb = 0;
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account resistances  : oui");
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account capacities   : oui");
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account VSC modelisation : non");
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account current ratio of tap changers : oui");
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account loads        : oui");
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account shunts       : non");
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account mutual lines : non");
            reporterCourcirc.report("REC_"+ recNb++, "Taking into account sub-transient values : non");
            reporterCourcirc.report("REC_"+ recNb++, "Interior area = whole network");
            for(int j=0 ; j < 5 ; j++)
                reporterCourcirc.report("REC_"+ recNb++, "T.NODE"+j+" : transient reactance too low ==> generator ignored");
        }
    }

    @Test
    void testEmptyReporter() {
        assertThat(reportMapper.modifyReporter(Reporter.NO_OP)).isInstanceOf(Reporter.NoOpImpl.class).isSameAs(Reporter.NO_OP);
    }

    @Test
    void testIgnoreOthersReportModels() {
        final Reporter reporter = new ReporterModel("test", "Test node");
        assertThat(reportMapper.modifyReporter(reporter)).isSameAs(reporter);
    }

    @Test
    void testModifyRootNode() {
        final Reporter targetReporter = new ReporterModel(ROOT_REPORTER_ID, ROOT_REPORTER_ID);
        final Reporter reporter = targetReporter.createSubReporter(SHORTCIRCUIT_TYPE_REPORT, SHORTCIRCUIT_TYPE_REPORT + " (${providerToUse})", "providerToUse", ShortCircuitAnalysis.find().getName());
        assertThat(reporter).isInstanceOf(ReporterModel.class);
        reporter.createSubReporter("generatorConversion", "Conversion of generators")
                .report("disconnectedTerminalGenerator", "Regulating terminal of connected generator ${generator} is disconnected. Regulation is disabled.", "generator", "TestGenerator");
        assertThat(reportMapper.modifyReporter(targetReporter))
                .isNotSameAs(targetReporter)
                .usingRecursiveComparison(RecursiveComparisonConfiguration.builder()
                        .withIgnoreCollectionOrder(false)
                        .withIgnoreAllOverriddenEquals(true)
                        .build())
                .isEqualTo(targetReporter);
    }

    @Test
    void testModificationLogs() throws JsonProcessingException {
        final ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json()
                .findModulesViaServiceLoader(true)
                .build();

        final ReporterModel targetReporter = new ReporterModel(ROOT_REPORTER_ID, ROOT_REPORTER_ID);
        final Reporter reporter = targetReporter.createSubReporter(SHORTCIRCUIT_TYPE_REPORT, SHORTCIRCUIT_TYPE_REPORT + " (${providerToUse})", "providerToUse", ShortCircuitAnalysis.find().getName());
        reporter.createSubReporter("generatorConversion", "Conversion of generators")
                .report("disconnectedTerminalGenerator", "Regulating terminal of connected generator ${generator} is disconnected. Regulation is disabled.", "generator", "TestGenerator");
        final Reporter reporter1 = reporter.createSubReporter("batteryConversion", "Conversion of the batteries");
        reporter1.createSubReporter("lineConversion", "Conversion of lines");
        reporter1.createSubReporter("tieLineConversion", "Conversion of tie lines");
        reporter1.createSubReporter("twoWindingsTransformerConversion", "Conversion of two windings transformers");
        reporter1.createSubReporter("threeWindingsTransformerConversion", "Conversion of three windings transformers");
        reporter.createSubReporter("danglinglinesConversion", "Conversion of the dangling lines");
        final Reporter reporterCourcirc = reporter.createSubReporter("courcirc", "Logs generated by Courcirc simulator");
        reporterCourcirc.report("REC_0", "Taking into account resistances  : oui");
        reporterCourcirc.report("REC_1", "Taking into account capacities   : oui");
        reporterCourcirc.report("REC_2", "Taking into account VSC modelisation : non");
        reporterCourcirc.report("REC_3", "Taking into account current ratio of tap changers : oui");
        reporterCourcirc.report("REC_4", "Taking into account loads        : oui");
        reporterCourcirc.report("REC_5", "Taking into account shunts       : non");
        reporterCourcirc.report("REC_6", "Taking into account mutual lines : non");
        reporterCourcirc.report("REC_7", "Taking into account sub-transient values : non");
        reporterCourcirc.report("REC_8", "Interior area = whole network");
        reporterCourcirc.report("TransientReactanceTooLow", "${nb} node(s) with transient reactance too low ==> generator ignored\n${nodes}",
                Map.of("nb", new TypedValue(5, TypedValue.UNTYPED), "nodes", new TypedValue("T.NODE0, T.NODE1, T.NODE2, T.NODE3, T.NODE4", TypedValue.UNTYPED)));

        final Reporter result = reportMapper.modifyReporter(rootReporter);
        log.debug("Result = {}", objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(result));
        assertThat(result)
                .isNotSameAs(rootReporter)
                .asInstanceOfReportModel()
                .usingRecursiveComparison(RecursiveComparisonConfiguration.builder()
                        .withIgnoreCollectionOrder(false)
                        .withIgnoreAllOverriddenEquals(true)
                        .build())
                .isEqualTo(targetReporter);
    }
}
